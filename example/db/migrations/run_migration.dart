// Generated file - DO NOT EDIT
// This file is automatically generated when migrations are created

import 'dart:io';

import 'package:d_server/d_server.dart';

import '../migrate/20251021094924_create_todos.dart';
import '../migrate/20251026162521_create_task.dart';

void main(List<String> args) async {
  // Setup database connection
  try {
    final config = await DConfig.loadFromFile('config/config.yml');
    final dbConfig = {
      'ssl': config.get<bool>('database.ssl'),
      'host': config.get<String>('database.host'),
      'port': config.get<int>('database.port'),
      'database': config.get<String>('database.database'),
      'username': config.get<String>('database.username'),
      'password': config.get<String>('database.password'),
    };
    await DatabaseConnection.fromConfig(dbConfig);
  } catch (e) {
    print('Failed to setup database connection: $e');
    return;
  }

  final command = args.isNotEmpty ? args[0] : 'migrate';
  final target = args.length > 1 ? args[1] : null;

  final migrations = <String, Migration Function()>{
    '20251021094924_create_todos.dart': () => CreateTodos(),
    '20251026162521_create_task.dart': () => CreateTask(),
  };

  if (command == 'rollback') {
    await handleRollback(target, migrations);
  } else {
    await handleMigrate(target, migrations);
  }
  exit(0);
}

Future<void> handleMigrate(String? target, Map<String, Migration Function()> migrations) async {
  if (target != null) {
    // Run specific migration
    final migrationFactory = migrations[target];
    if (migrationFactory != null) {
      final migration = migrationFactory();
      print("Running migration: $target");
      await migration.up();
      print("Migration $target completed");
    } else {
      print("Migration $target not found");
    }
  } else {
    // Run all migrations
    print("Running all migrations...");
    for (final entry in migrations.entries) {
      final migration = entry.value();
      print("Running migration: ${entry.key}");
      await migration.up();
      print("Migration ${entry.key} completed");
    }
    print("All migrations completed");
  }
}

Future<void> handleRollback(String? target, Map<String, Migration Function()> migrations) async {
  if (target != null) {
    final steps = int.tryParse(target);
    if (steps != null) {
      // Rollback N steps
      print("Rolling back $steps step(s)...");
      final migrationList = migrations.entries.toList().reversed.take(steps);
      for (final entry in migrationList) {
        final migration = entry.value();
        print("Rolling back migration: ${entry.key}");
        await migration.down();
        print("Migration ${entry.key} rolled back");
      }
    } else {
      // Rollback specific migration
      final migrationFactory = migrations[target];
      if (migrationFactory != null) {
        final migration = migrationFactory();
        print("Rolling back migration: $target");
        await migration.down();
        print("Migration $target rolled back");
      } else {
        print("Migration $target not found");
      }
    }
  } else {
    // Rollback last migration
    print("Rolling back last migration...");
    if (migrations.isNotEmpty) {
      final lastEntry = migrations.entries.last;
      final migration = lastEntry.value();
      print("Rolling back migration: ${lastEntry.key}");
      await migration.down();
      print("Migration ${lastEntry.key} rolled back");
    } else {
      print("No migrations to rollback");
    }
  }
}
